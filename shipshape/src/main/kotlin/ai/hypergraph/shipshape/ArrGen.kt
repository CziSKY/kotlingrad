package ai.hypergraph.shipshape

import org.intellij.lang.annotations.Language

var generatePseudoConstructors = false

@Language("kt")
fun genArrays() = """
// This file was generated by Shipshape
@file:Suppress("UNUSED_PARAMETER", "UNCHECKED_CAST")

package ai.hypergraph.kotlingrad.typelevel.array
 
import ai.hypergraph.kotlingrad.typelevel.church.*
import kotlin.jvm.JvmName

// Multi-typed arrays
${genMultitypedArrays()}

open class VT<E, L: S<*>> internal constructor(val len: L, val a: List<E>): List<E> by a {
  internal constructor(l: L, vararg es: E): this(l, es.toList())

  internal fun <A: S<*>, B: S<*>> fetch(intRange: Y2<A, B>): List<E> = subList(intRange.e1.toInt(), intRange.e2.toInt())
}

/** TODO: Unify this representation with [ai.hypergraph.kaliningraph.tensor.Matrix] */
typealias Mat<E, R, C> = VT<VT<E, C>, R>

infix fun <T> T.cc(that: T) = VT(this, that)

fun <T1: VT<E, L>, E, L: S<*>> T1.append(that: E): VT<E, Q1<L>> = VT(this.len + S1, this.a + listOf(that))
fun <T1: VT<E, L>, E, L: S<*>> T1.prepend(that: E): VT<E, Q1<L>> = VT(this.len + S1, listOf(that) + this.a)

${genArrayConcatenators()}

${genArrayPseudoConstructors()}

${genArrayTypeAliases()}

fun <E, D1: S<*>, D2: S<*>> List<E>.chunked(d1: D1, d2: D2): List<VT<E, D2>> = chunked(d1.toInt()).map { VT(d2, it) }

inline fun <reified R: S<*>> asInt() = R::class.simpleName!!.drop(1).toInt()
fun <E, R: S<*>, C: S<*>> Mat(r: R, c: C, vararg es: E): Mat<E, R, C> = Mat(r, c, es.toList())
fun <E, R: S<*>, C: S<*>> Mat(r: R, c: C, es: List<E>): Mat<E, R, C> = Mat(r, es.chunked(r, c))
fun <E, R: S<*>, C: S<*>> Mat(r: R, c: C, f: (Int, Int) -> E): Mat<E, R, C> =
  Mat(r, c, allPairs(r.toInt(), c.toInt()).map { (r, c) -> f(r, c) })

operator fun IntRange.times(s: IntRange): Set<V2<Int>> = flatMap { l -> s.map { r -> l cc r }.toSet() }.toSet()
fun allPairs(numRows: Int, numCols: Int): Set<V2<Int>> = (0 until numRows) * (0 until numCols)

//...Optional pseudoconstructors
${if (generatePseudoConstructors) genMatPseudoConstructors() else "// Disabled"}

operator fun <E, R: S<*>, C1: S<*>, C2: S<*>> Mat<E, R, C1>.times(that: Mat<E, C1, C2>): Mat<E, R, C2> = TODO()
operator fun <E, R: S<*>, C: S<*>> Mat<E, R, C>.get(r: Int, c: Int): E = a[r][c]
//fun <E, R: S<*>, C: S<*>> Mat<E, R, C>.transpose(): Mat<E, C, R> = Mat { r, c -> this[c][r]}

${genTypesafeArrayGetters()}

val <R, L : Q1<R>, E> VT<E, L>.first: E get() = component1()
val <R, L : Q2<R>, E> VT<E, L>.second: E get() = component2()
val <R, L : Q3<R>, E> VT<E, L>.third: E get() = component3()

operator fun <T> Array<T>.get(range: IntRange) = sliceArray(range)

${genTypesafeArrayTakes()}

${genTypesafeArrayDrops()}

//                              ┌────j────┐    ┌────k────┐    where j, j are the relative offsets Y - X, Z - Y respectively
// Encodes the constraint:  P < X    <    Y && Y    <    Z    where X, Y are the start and end of range in a vector of length Z
@JvmName("sv121") operator fun <E, X: Q1<P>, Y: Q2<X>, Z : Q1<Y>, P> VT<E, Z>.get(r: Y2<X, Y>): VT<E, L2> = VT(S2, fetch(r))
@JvmName("sv122") operator fun <E, X: Q1<P>, Y: Q2<X>, Z : Q2<Y>, P> VT<E, Z>.get(r: Y2<X, Y>): VT<E, L2> = VT(S2, fetch(r))
@JvmName("sv221") operator fun <E, X: Q2<P>, Y: Q2<X>, Z : Q1<Y>, P> VT<E, Z>.get(r: Y2<X, Y>): VT<E, L2> = VT(S2, fetch(r))
@JvmName("sv222") operator fun <E, X: Q2<P>, Y: Q2<X>, Z : Q2<Y>, P> VT<E, Z>.get(r: Y2<X, Y>): VT<E, L2> = VT(S2, fetch(r))
// TODO: Finish

operator fun <A, B> S<A>.rangeTo(that: S<B>) = Y2(this, that)
""".trimIndent()

fun genTypesafeArrayTakes() =
  (1..maxDim).joinToString("\n") {
    "fun <E, Z : Q$it<P>, P> VT<E, Z>.take$it(): VT<E, L$it> = VT(S$it, fetch(S0..S$it))"
  }

fun genTypesafeArrayDrops() =
  (1 until maxDim).joinToString("\n") {
    "fun <E, Z : Q${it+1} <P>, P> VT<E, Z>.drop$it(): VT<E, S<P>> = VT(len - S$it, fetch(S$it..len))"
  }

fun genTypesafeArrayGetters() =
  (1..maxDim).joinToString("\n") {
    "@JvmName(\"get$it\") operator fun <R, L : Q$it<R>, E> VT<E, L>.get(i: L$it) = a[${it-1}]"
  }

fun genMatPseudoConstructors() =
  cartProd(1..maxDim) { i, j ->
    "fun <E> Mat${i}x${j}(${(1..(i * j)).joinToString { "e$it: E" }}): Mat<E, L$i, L$j> = " +
      "Mat(S$i, S$j, ${(1..(i * j)).joinToString { "e$it" }})"
  }

fun genArrayTypeAliases() =
  (1..maxDim).joinToString("\n") { "typealias V$it<E> = VT<E, L$it>" }

fun genArrayPseudoConstructors(
  mtaRange: IntRange = 1..maxDim,
  genParams: (Int) -> String = { num -> (1..num).joinToString(", ") { "v$it: E" } },
  genArgs: (Int) -> String = { num -> (1..num).joinToString(", ") { "v$it" } },
) = mtaRange.joinToString("\n") { "fun <E> VT(${genParams(it)}) = VT(S$it, ${genArgs(it)})" }

fun genArrayConcatenators() =
  twoToMax.joinToString("\n") {
    "@JvmName(\"cc$it\") infix fun <T1: VT<E, L>, T2: VT<E, L${it-1}>, E, L: S<*>> T1.cc(that: T2): VT<E, Q${it-1}<L>> = VT(this.len + that.len, this.a + that.a)"
  }

fun genMultitypedArrays(
  mtaRange: IntRange = 1..maxDim,
  genParams: (Int) -> String = { num -> (1..num).joinToString(", ") { "val e$it: E$it" } },
  genTypeParams: (Int) -> String = { num -> (1..num).joinToString(", ") { "E$it" } },
) = mtaRange.joinToString("\n") { "data class Y$it<${genTypeParams(it)}>(${genParams(it)})" }

data class Y1<A>(val e1: A)
data class Y2<A, B>(val e1: A, val e2: B)
data class Y3<A, B, C>(val e1: A, val e2: B, val e3: C)
data class Y4<A, B, C, D>(val e1: A, val e2: B, val e3: C, val e4: D)

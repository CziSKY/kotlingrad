package ai.hypergraph.shipshape

import org.intellij.lang.annotations.Language

fun main() {
  println(genChurchArithmetic())
}

var twoToMax = 2..maxDim

@Language("kt")
fun genChurchArithmetic() = """
// This file was generated by Shipshape
@file:Suppress("UNUSED_PARAMETER", "UNCHECKED_CAST")

package ai.hypergraph.kotlingrad.typelevel.church

import kotlin.jvm.JvmName

open class S<X>(val x: X?) {
  override fun equals(other: Any?) = if(other is S<*>) if(x == null && other.x == null) true else x == other.x else false
  override fun hashCode() = x.hashCode().hashCode()
}
object O: S<O>(null)
fun S<*>.toInt(i: Int = 0): Int = (x as? S<*>)?.toInt(i + 1) ?: i

operator fun Number.plus(s: S<*>): Int = toInt() + s.toInt()
operator fun Number.minus(s: S<*>): Int = toInt() - s.toInt()
operator fun Number.times(s: S<*>): Int = toInt() * s.toInt()
operator fun Number.div(s: S<*>): Int = toInt() / s.toInt()

operator fun S<*>.plus(n: Number): Int = toInt() + n.toInt()
operator fun S<*>.minus(n: Number): Int = toInt() - n.toInt()
operator fun S<*>.times(n: Number): Int = toInt() * n.toInt()
operator fun S<*>.div(n: Number): Int = toInt() / n.toInt()

${genAliases()}

${genConsts()}

${genArithmetic()}
""".trimMargin()

tailrec fun genChurchNat(i: Int, prev: String = "K", lr: Pair<Char, Char> = '<' to '>'): String =
  if (i == 0) prev else genChurchNat(i - 1, "S${lr.first}$prev${lr.second}", lr)

fun genAliases(): String =
  "val S0: L0 = O\n" + "val S1: L1 = S(O)" +
    twoToMax.joinToString("\n", "\n") { "val S$it: L$it = S(S${it - 1})" } +
//    range.joinToString("\n") { balancedPartition(it).let { (a, b) -> "val S$it = S$a.plus$b()" } } +
    "\n\ntypealias L0 = O\ntypealias L1 = S<O>\n" +
    twoToMax.joinToString("\n") { "typealias L$it = Q$it<O>" } +
    "\ntypealias Q1<T> = S<T>\n" +
    twoToMax.joinToString("\n") { "typealias Q$it<T> = S<Q${it-1}<T>>" }

fun genConsts(): String =
  """
    fun <W: S<*>, X: S<W>> W.plus1(): X = S(this) as X
    fun <W: S<*>, X: S<W>> X.minus1(): W = x as W
  """.trimIndent() + twoToMax.joinToString( "\n", "\n" ) {
    val (a, b) = balancedPartition(it)
    """
      fun <W: S<*>, X: Q$it<W>> W.plus$it(): X = plus$a().plus$b()
      fun <W: S<*>, X: Q$it<W>> X.minus$it(): W = minus$a().minus$b()
    """.trimIndent()
  }

fun balancedPartition(i: Int): Pair<Int, Int> =
  (i / 2).let { half -> half to if (half * 2 == i) half else half + 1 }

fun genArithmetic(
  ops: Map<Pair<String, String>, (Int, Int) -> Int> = mapOf(
    "times" to "*" to { a, b -> a * b },
    "div" to "รท" to { a, b -> if ((a / b) * b == a) a / b else Int.MIN_VALUE },
  )
) = genSpecials() + "\n" + genPlus() + "\n" + genMinus() + "\n" +
  (twoToMax * twoToMax * ops.entries).filter { (a, b, c) -> c.value(a, b) in twoToMax }
    .joinToString("\n", "\n") { (a, b, c) ->
      val res = c.value(a, b)
      val op = c.key.second
      val name = c.key.first
      "@JvmName(\"$a$op$b\") operator fun <W: L$a, X: L$b> W.$name(x: X): L${res} = S${res}"
    }

fun genPlus() =
  twoToMax.joinToString("\n", "\n") {
    """
      @JvmName("n+$it") operator fun <V: L$it, W: S<*>, X: Q$it<W>> W.plus(x: V): X = plus$it()
    """.trimIndent()
  }

// I think this is called a quotient type? https://en.wikipedia.org/wiki/Quotient_type
fun genMinus() =
  twoToMax.joinToString("\n", "\n") {
    """
      @JvmName("n-$it") operator fun <V: L$it, W: S<*>, X: Q$it<W>> X.minus(v: V): W = minus$it()
    """.trimIndent()
  }

operator fun IntRange.times(s: IntRange) =
  flatMap { l -> s.map { r -> l to r }.toSet() }.toSet()

operator fun <T, Y, Z> Set<Pair<T, Y>>.times(s: Set<Z>): Set<Triple<T, Y, Z>> =
  flatMap { (l, ll) -> s.map { r -> Triple(l, ll, r) }.toSet() }.toSet()

fun genSpecials() =
  """
    @JvmName("n+0") operator fun <W: S<*>> W.plus(x: O): W = this
    @JvmName("0+n") operator fun <X: S<*>> O.plus(x: X): X = x
    @JvmName("n+1") operator fun <W: S<*>, X: S<O>> W.plus(x: X): S<W> = plus1()
    @JvmName("1+n") operator fun <W: S<*>, X: S<O>> X.plus(w: W): S<W> = w.plus1()
    @JvmName("n-1") operator fun <W: S<*>, X: S<W>, Y: S<O>> X.minus(y: Y): W = minus1()
    @JvmName("nรท1") operator fun <W: S<*>, X: S<O>> W.div(x: X): W = this
    @JvmName("n*1") operator fun <W: S<*>, X: S<O>> W.times(x: X): W = this
    @JvmName("1*n") operator fun <W: S<*>, X: S<O>> X.times(w: W): W = w
    @JvmName("n*0") operator fun <W: S<*>> W.times(x: O): O = O
    @JvmName("0*n") operator fun <X: S<*>> O.times(x: X): O = O
  """.trimIndent()
package ai.hypergraph.shipshape

import org.intellij.lang.annotations.Language
import kotlin.math.*

fun main() {
  println(genBooleanTypeAliases())
}

@Language("kt")
fun genBinaryArithmetic() = """
// This file was generated by Shipshape

@file:Suppress("UNUSED_PARAMETER", "UNCHECKED_CAST")
package ai.hypergraph.kotlingrad.typelevel.binary

import kotlin.jvm.JvmName

sealed class B<X, P : B<X, P>>(open val x: X? = null) {
  val T: T<P> get() = T(this as P)
  val F: F<P> get() = F(this as P)

  abstract fun flip(): B<X, *>
  override fun equals(other: Any?) = toString() == other.toString()
  override fun hashCode() = this::class.hashCode() + x.hashCode()
  override fun toString() = "" + (x ?: "") + if (this is T) "1" else "0"
}

open class T<X>(override val x: X = Ø as X) : B<X, T<X>>(x) {
  companion object: T<Ø>(Ø)
  override fun flip(): F<X> = F(x)
}
open class F<X>(override val x: X = Ø as X) : B<X, F<X>>(x) {
  companion object: F<Ø>(Ø)
  override fun flip(): T<X> = T(x)
}

@Suppress("NonAsciiCharacters", "ClassName")
object Ø: B<Ø, Ø>(null) { override fun flip() = Ø }

fun B<*, *>.toInt(): Int = toInt(toString())
tailrec fun toInt(s: String, sum: Int = 0): Int =
  if (s.isEmpty()) sum else toInt(s.substring(1), (sum shl 1) + s[0].digitToInt())

/**
*     i │  0  1  …  k-1  k  │  k+1  k+2  …  k+c  │  k+c+1  …  k+c+k   
*    ───┼───────────────────┼────────────────────┼───────────────────┐ ┐
*     0 │                   │                    │                __/  │ 
*     1 │                   │                    │             __/XXX  │
*     … │       i ± i       │        k ± i       │          __/XXXXXX  ├ ┐
*   k-1 │                   │                    │      ___/XXXXXXXXX  │ │
*     k │                   │                    │  ___╱XXXXXXXXXXXXX  │ │
*   ────┼───────────────────┼────────────────────┴─┘XXXXXXXXXXXXXXXXX  ┘ │
*   k+1 │                   │XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX    │
*   k+2 │                   │XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX    │
*     … │       i ± k       │XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX    │
*     … │                   │XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX    │ 
*   k+c │                   │XXXXXXXXXXXX                XXXXXXXXXXXX    │
*  ─────┼───────────────────┤XXXXXXXXXXXX    Run-time    XXXXXXXXXXXX    │
* k+c+1 │               ___/XXXXXXXXXXXXX  type checked  XXXXXXXXXXXX    │
*     … │           ___/XXXXXXXXXXXXXXXXX                XXXXXXXXXXXX    │
*     … │       ___/XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX    │
*     … │   ___/XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX    │
* k+c+k │__/XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX    │
*                                                                      
*       └─────────┬─────────┘                               Compile-time
*                 └─────────────────────────────────────    type checked 
*/

// Left padded with 0, B_0N indicates a binary string *0{B_0N}
// Enumerate (max(2ⁱ-k, 0), 2ⁱ+k) ∀0≤i≤⌊log₂(k+c+k)⌋
// i.e.: {0, 1, 2, *(4-k, 4+k), *(8-k, 8+k), *(16-k, 16+k),..., *(2^⌊log₂(k+c+k)⌋-k, 2^⌊log₂(k+c+k)⌋+k)}

${genBooleanTypeAliases()}

${genBooleanLiterals()}

${genBooleanPlusMinusOne(maxPow = 8)}

${genBooleanPlusMinus()}

${genMultiplicationTable()}

${genDivisionTable()}
"""

fun genBooleanTypeAliases(pow: Int = 8, const: Int = 6): String =
  (0..pow).asSequence().map { 2.0.pow(it).toInt() }
    .map { (it - const).coerceAtLeast(0) until (it + const) }
    .flatten().distinct().joinToString("\n") { "typealias B_$it<B> = ${it.toBigEndian("B")}" }


fun genBooleanLiterals(const: Int = 6): String =
  "val B0: B_0<Ø> = F(Ø)\nval B1: B_1<Ø> = T(Ø)\n" +
  (2..const).joinToString("\n") { "val B$it: B_$it<Ø> = ${it.toBigEndianVal()}" }

fun genBooleanPlusMinus(maxPow: Int = 8, const: Int = 6): String =
  """
    @JvmName("b_p_") operator fun <K> K.plus(k: K) = F(k)
    @JvmName("b_m_") operator fun <K> K.minus(k: K) = F(Ø)
  """.trimIndent() + (2..const).joinToString("\n", "\n") { k ->
    val (p1, p2) = balancedPartition(k)
    val (v1, v2) = "B$p1" to "B$p2"

    val range = (0..maxPow).asSequence().map { 2.0.pow(it).toInt() }
      .map { ((it - k).coerceAtLeast(0) until it).toList() }
      .flatten().distinct()
    range.joinToString("\n", "\n", "\n") {
      val result = it + k
      """@JvmName("bop${it}p$k") operator fun B_${it}<Ø>.plus(r: B_${k}<Ø>): B_$result<Ø> = plus($v2) + $v1"""
    } + range.joinToString("\n", "\n", "\n") {
      val lpad = (it + k).toString(2).length - it.toString(2).length
      val fpad = "F".repeat(lpad).toBigEndian("K")
      """@JvmName("bop?0${it}p$k") operator fun <K: B<*, *>> B_${it}<$fpad>.plus(r: B_${k}<Ø>) = plus($v2) + $v1"""
    } + range.map { it + k }.joinToString("\n", "\n", "\n") {
      val result = it - k
      """@JvmName("bop${it}m$k") operator fun B_${it}<Ø>.minus(r: B_${k}<Ø>): B_$result<Ø> = minus($v2) - $v1"""
    } + range.map { it + k }.joinToString("\n", "\n", "\n") {
      val result = it - k
      """@JvmName("bop?${it}m$k") operator fun <K: B<*, *>> B_${it}<K>.minus(r: B_${k}<Ø>) = minus($v2) - $v1"""
    }
  }

fun genBooleanPlusMinusOne(maxPow: Int, range: Sequence<Int> = (1..maxPow).asSequence().map { 2.0.pow(it).toInt() }) =
  """
    @JvmName("bnp1") operator fun Ø.plus(t: T<Ø>) = B1
    @JvmName("b0p1") operator fun B_0<Ø>.plus(t: T<Ø>) = B1
  """.trimIndent() + range.joinToString("\n", "\n") {
    val result = it
    """@JvmName("b${it - 1}p1") operator fun B_${it - 1}<Ø>.plus(t: T<Ø>): B_$result<Ø> = F(x + B1)"""
    } + "\n\n" + """@JvmName("b?0p1") operator fun <K: B<*, *>> B_0<K>.plus(t: T<Ø>) = T(x)""" +
    range.joinToString("\n", "\n", "\n\n") {
      """@JvmName("b?0${it - 1}p1") operator fun <K: B<*, *>> B_${it - 1}<F<K>>.plus(t: T<Ø>) = F(x + B1)"""
    } + """
      @JvmName("b1m1") operator fun B_1<Ø>.minus(t: T<Ø>): B_0<Ø> = B0
      @JvmName("b2m1") operator fun B_2<Ø>.minus(t: T<Ø>): B_1<Ø> = B1
      """.trimIndent() +
    range.drop(1).joinToString("\n", "\n", "\n\n") {
      val result = it - 1
      """@JvmName("b${it}m1") operator fun B_${it}<Ø>.minus(t: T<Ø>): B_$result<Ø> = T(x - B1)"""
    } + """@JvmName("b?1p1") operator fun <K: B<*, *>> B_1<K>.minus(t: T<Ø>) = F(x)""" +
    range.joinToString("\n", "\n") {
      val result = it - 1
      """@JvmName("b?${it}m1") operator fun <K: B<*, *>> B_${it}<K>.minus(t: T<Ø>) = T(x - B1)"""
    }

fun genMultiplicationTable(
  range: IntRange = 2..16,
  easy: Set<Int> = range.filter { log2(it.toFloat()).let { ceil(it) == floor(it) } }.toSet(),
  hard: Set<Int> = range.filter { log2(it.toFloat()).let { ceil(it) != floor(it) } }.toSet()
) =
  """
    @JvmName("b_t0") operator fun <K: B<*, *>> K.times(t: F<Ø>) = t
    @JvmName("b0t_") operator fun <K: B<*, *>> F<Ø>.times(t: K) = this
    @JvmName("b_t1") operator fun <K: B<*, *>> K.times(t: T<Ø>) = this
    @JvmName("b1t_") operator fun <K: B<*, *>> T<Ø>.times(t: K) = t
  """.trimIndent() +
    easy.joinToString("\n","\n","\n") {
      val pow = log2(it.toFloat()).toInt()
      val padthis = "F".repeat(pow).toBigEndianVal("this")
      val padarg = "F".repeat(pow).toBigEndianVal("t")
      """
        @JvmName("b_t${it}") operator fun <K: B<*, *>> K.times(t: B_$it<Ø>) = $padthis
        @JvmName("b${it}t_") operator fun <K: B<*, *>> B_$it<Ø>.times(t: K) = $padarg
      """.trimIndent()
    } + (hard * hard).joinToString("\n", "\n") { (a, b) ->
      val result = (a * b).toBigEndian("Ø", "(", ")")
      """
        @JvmName("b${a}t${b}") operator fun B_$a<Ø>.times(t: B_$b<Ø>) = $result
      """.trimIndent()
    }

fun genDivisionTable(
  maxPow: Int = 8,
  range: IntRange = 1..maxPow,
  easy: Set<Int> = range.map { 2.0.pow(it).toInt() }.toSet(),
  hard: Set<Triple<Int, Int, Int>> =
    (2..2.0.pow(maxPow).toInt()).map { it.nontrivialDivisors() }.flatten().toSet()
) =
  """
    @JvmName("b_d1") operator fun <K: B<*, *>> K.div(t: T<Ø>) = this
    @JvmName("b_d_") operator fun <K> K.div(t: K) = T(Ø)
  """.trimIndent() + easy.joinToString("\n", "\n", "\n") {
      val pow = log2(it.toFloat()).toInt()
      val pad = "F".repeat(pow).toBigEndian("K")
      val divisor = "x".repeat(pow).toCharArray().joinToString(".").ifEmpty { "this" }
      """@JvmName("b_d$it") fun <K: B<*, *>> $pad.div(d: ${it.toBigEndian("Ø")}) = $divisor""".trimIndent()
    } + hard.joinToString("\n", "\n", "\n") { (a, b, c) ->
    val dividend = a.toBigEndian("Ø")
    val divisor = b.toBigEndian("Ø")
    val quotient = c.toBigEndian("Ø", "(", ")")
    """
      @JvmName("b${a}d${b}") operator fun $dividend.div(d: $divisor) = $quotient
    """.trimIndent()
  }

fun Int.nontrivialDivisors(numToTake: Int = 20) =
  (1..(this/2 + 1))
    .asSequence().filter { !it.isPowerOfTwo() && (this % it) == 0 }
    .take(numToTake).map { Triple(this, it, this / it) }.toList()

fun Int.isPowerOfTwo() = log2(toFloat()).let { ceil(it) == floor(it) }

fun Int.toBigEndianVal() =
//  toString(2).fold("Ø") { a, b -> if(b == '0') "F($a)" else "T($a)" }
  toString(2).toCharArray().joinToString(".") { if (it == '1') "T" else "F" }
//  toString(2).fold("") { a, b -> (if(a.isEmpty()) "" else "$a.") + if(b == '0') "F" else "T" }

fun Int.toBigEndian(typeParam: String, lp: String = "<", rp: String = ">") =
  toString(2).fold(typeParam) { a, b -> if(b == '0') "F$lp$a$rp" else "T$lp$a$rp" }

fun String.toBigEndian(typeParam: String) = fold(typeParam) { a, b -> "$b<$a>" }

fun String.toBigEndianVal(typeParam: String) = fold(typeParam) { a, b -> "$b($a)" }
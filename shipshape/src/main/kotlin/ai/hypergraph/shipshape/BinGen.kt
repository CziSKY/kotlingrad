package ai.hypergraph.shipshape

import org.intellij.lang.annotations.Language
import kotlin.math.pow

fun main() {
  println(genBooleanTypeAliases())
}

@Language("kt")
fun genBinaryArithmetic() = """
// This file was generated by Shipshape

@file:Suppress("UNUSED_PARAMETER", "UNCHECKED_CAST")
package ai.hypergraph.kotlingrad.typelevel.binary.arithmetic

import kotlin.jvm.JvmName

sealed class B<X, P : B<X, P>>(open val x: X? = null) {
  val T: T<P> get() = T(this as P)
  val F: F<P> get() = F(this as P)

  abstract fun flip(): B<X, *>
  override fun equals(other: Any?) = toString() == other.toString()
  override fun hashCode() = this::class.hashCode() + x.hashCode()
  override fun toString() = "" + (x ?: "") + if (this is T) "1" else "0"
}

open class T<X>(override val x: X = Ø as X) : B<X, T<X>>(x) {
  companion object: T<Ø>(Ø)
  override fun flip(): F<X> = F(x)
}
open class F<X>(override val x: X = Ø as X) : B<X, F<X>>(x) {
  companion object: F<Ø>(Ø)
  override fun flip(): T<X> = T(x)
}

@Suppress("NonAsciiCharacters", "ClassName")
object Ø: B<Ø, Ø>(null) { override fun flip() = Ø }

fun B<*, *>.toInt(): Int = toInt(toString())
tailrec fun toInt(s: String, sum: Int = 0): Int =
  if (s.isEmpty()) sum else toInt(s.substring(1), (sum shl 1) + s[0].digitToInt())

/**
*     i │  0  1  …  k-1  k  │  k+1  k+2  …  k+c  │  k+c+1  …  k+c+k   
*    ───┼───────────────────┼────────────────────┼───────────────────┐ ┐
*     0 │                   │                    │                __/  │ 
*     1 │                   │                    │             __/XXX  │
*     … │       i ± i       │        k ± i       │          __/XXXXXX  ├ ┐
*   k-1 │                   │                    │      ___/XXXXXXXXX  │ │
*     k │                   │                    │  ___╱XXXXXXXXXXXXX  │ │
*   ────┼───────────────────┼────────────────────┴─┘XXXXXXXXXXXXXXXXX  ┘ │
*   k+1 │                   │XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX    │
*   k+2 │                   │XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX    │
*     … │       i ± k       │XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX    │
*     … │                   │XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX    │ 
*   k+c │                   │XXXXXXXXXXXX                XXXXXXXXXXXX    │
*  ─────┼───────────────────┤XXXXXXXXXXXX    Run-time    XXXXXXXXXXXX    │
* k+c+1 │               ___/XXXXXXXXXXXXX  type checked  XXXXXXXXXXXX    │
*     … │           ___/XXXXXXXXXXXXXXXXX                XXXXXXXXXXXX    │
*     … │       ___/XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX    │
*     … │   ___/XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX    │
* k+c+k │__/XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX    │
*                                                                      
*       └─────────┬─────────┘                               Compile-time
*                 └─────────────────────────────────────    type checked 
*/

// Left padded with 0, B_0N indicates a binary string *0{B_0N}
// Enumerate (max(2ⁱ-k, 0), 2ⁱ+k) ∀0≤i≤⌊log₂(k+c+k)⌋
// i.e.: {0, 1, 2, *(4-k, 4+k), *(8-k, 8+k), *(16-k, 16+k),..., *(2^⌊log₂(k+c+k)⌋-k, 2^⌊log₂(k+c+k)⌋+k)}

${genBooleanTypeAliases()}

fun <K: B<*, *>> K.shl() = F
fun <K: B<*, *>> K.times2() = F
fun <K: B<*, *>> K.times4() = F.F
fun <K: B<*, *>> K.times8() = F.F.F
fun <K: B<*, *>> K.times16() = F.F.F.F
fun <K: B<*, *>> F<K>.div2() = x
fun <K: B<*, *>> F<F<K>>.div4() = x.x
fun <K: B<*, *>> F<F<F<K>>>.div8() = x.x.x
fun <K: B<*, *>> F<F<F<F<K>>>>.div16() = x.x.x.x

@JvmName("bnp1") operator fun Ø.plus(t: T<Ø>) = T(Ø)
${genBooleanPlusMinusOne(maxPow = 6)}

${genBooleanPlusMinus()}
"""

fun genBooleanTypeAliases(pow: Int = 6, const: Int = 6): String =
  (0..pow).asSequence().map { 2.0.pow(it).toInt() }
    .map { (it - const).coerceAtLeast(0) until (it + const) }
    .flatten().distinct().joinToString("\n") { "typealias B_$it<B> = ${it.toBigEndian("B")}" }

fun genBooleanPlusMinus(const: Int = 6): String =
  (2..const).joinToString("\n") { k ->
    val (p1, p2) = balancedPartition(k)
    val (v1, v2) = p1.toBigEndianVal() to p2.toBigEndianVal()

    val range = (0..const).asSequence().map { 2.0.pow(it).toInt() }
      .map { ((it - k).coerceAtLeast(0) until it).toList() }
      .flatten().distinct()
    range.joinToString("\n", "\n", "\n") {
      val result = it + k
      """@JvmName("bop${it}p$k") operator fun B_${it}<Ø>.plus(r: B_${k}<Ø>): B_$result<Ø> = plus($v2) + $v1"""
    } + range.joinToString("\n", "\n", "\n") {
      val lpad = (it + k).toString(2).length - it.toString(2).length
      val fpad = "F".repeat(lpad).toBigEndian("K")
      """@JvmName("bop?0${it}p$k") operator fun <K: B<*, *>> B_${it}<$fpad>.plus(r: B_${k}<Ø>) = plus($v2) + $v1"""
    } + range.map { it + k }.joinToString("\n", "\n", "\n") {
      val result = it - k
      """@JvmName("bop${it}m$k") operator fun B_${it}<Ø>.minus(r: B_${k}<Ø>): B_$result<Ø> = minus($v2) - $v1"""
    } + range.map { it + k }.joinToString("\n", "\n", "\n") {
      val result = it - k
      """@JvmName("bop?${it}m$k") operator fun <K: B<*, *>> B_${it}<K>.minus(r: B_${k}<Ø>) = minus($v2) - $v1"""
    }
  }

fun genBooleanPlusMinusOne(maxPow: Int, range: Sequence<Int> = (1..maxPow).asSequence().map { 2.0.pow(it).toInt() }) =
  """@JvmName("b0p1") operator fun B_0<Ø>.plus(t: T<Ø>) = T(Ø)""" +
    range.joinToString("\n", "\n") {
      val result = it
      """@JvmName("b${it - 1}p1") operator fun B_${it - 1}<Ø>.plus(t: T<Ø>): B_$result<Ø> = F(x + T(Ø))"""
    } + "\n\n" + """@JvmName("b?0p1") operator fun <K: B<*, *>> B_0<K>.plus(t: T<Ø>) = T(x)""" +
    range.joinToString("\n", "\n", "\n\n") {
      """@JvmName("b?0${it - 1}p1") operator fun <K: B<*, *>> B_${it - 1}<F<K>>.plus(t: T<Ø>) = F(x + T(Ø))"""
    } + """
      @JvmName("b1m1") operator fun B_1<Ø>.minus(t: T<Ø>): B_0<Ø> = F(Ø)
      @JvmName("b2m1") operator fun B_2<Ø>.minus(t: T<Ø>): B_1<Ø> = T(Ø)
      """.trimIndent() +
    range.drop(1).joinToString("\n", "\n", "\n\n") {
      val result = it - 1
      """@JvmName("b${it}m1") operator fun B_${it}<Ø>.minus(t: T<Ø>): B_$result<Ø> = T(x - T(Ø))"""
    } + """@JvmName("b?1p1") operator fun <K: B<*, *>> B_1<K>.minus(t: T<Ø>) = F(x)""" +
    range.joinToString("\n", "\n") {
      val result = it - 1
      """@JvmName("b?${it}m1") operator fun <K: B<*, *>> B_${it}<K>.minus(t: T<Ø>) = T(x - T(Ø))"""
    }

fun Int.toBigEndianVal() =
  toString(2).fold("Ø") { a, b -> if(b == '0') "F($a)" else "T($a)" }
//  toString(2).fold("") { a, b -> (if(a.isEmpty()) "" else "$a.") + if(b == '0') "F" else "T" }

fun Int.toBigEndian(typeParam: String) =
  toString(2).fold(typeParam) { a, b -> if(b == '0') "F<$a>" else "T<$a>" }

fun String.toBigEndian(typeParam: String) = fold(typeParam) { a, b -> "$b<$a>" }
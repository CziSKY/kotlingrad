package ai.hypergraph.shipshape

import org.intellij.lang.annotations.Language
import kotlin.math.pow

fun main() {
  println(genBooleanTypeAliases())
}

@Language("kt")
fun genBinaryArithmetic() = """
// This file was generated by Shipshape

@file:Suppress("UNUSED_PARAMETER", "UNCHECKED_CAST")
package ai.hypergraph.kotlingrad.typelevel.binary.arithmetic

import kotlin.jvm.JvmName

sealed class B<X, P : B<X, P>>(open val x: X? = null) {
  val T: T<P> get() = T(this as P)
  val F: F<P> get() = F(this as P)

  abstract fun flip(): B<X, *>
  override fun equals(other: Any?) = toString() == other.toString()
  override fun hashCode() = this::class.hashCode() + x.hashCode()
  override fun toString() = "" + (x ?: "") + if (this is T) "1" else "0"
}

open class T<X>(override val x: X = Ø as X) : B<X, T<X>>(x) {
  companion object: T<Ø>(Ø)
  override fun flip(): F<X> = F(x)
}
open class F<X>(override val x: X = Ø as X) : B<X, F<X>>(x) {
  companion object: F<Ø>(Ø)
  override fun flip(): T<X> = T(x)
}

@Suppress("NonAsciiCharacters", "ClassName")
object Ø: B<Ø, Ø>(null) { override fun flip() = Ø }

fun B<*, *>.toInt(): Int = toInt(toString())
tailrec fun toInt(s: String, sum: Int = 0): Int =
  if (s.isEmpty()) sum else toInt(s.substring(1), (sum shl 1) + s[0].digitToInt())

/**
*     i │  0  1  …  k-1  k  │  k+1  k+2  …  k+c  │  k+c+1  …  k+c+k   
*    ───┼───────────────────┼────────────────────┼───────────────────┐ ┐
*     0 │                   │                    │                __/  │ 
*     1 │                   │                    │             __/XXX  │
*     … │       i ± i       │        k ± i       │          __/XXXXXX  ├ ┐
*   k-1 │                   │                    │      ___/XXXXXXXXX  │ │
*     k │                   │                    │  ___╱XXXXXXXXXXXXX  │ │
*   ────┼───────────────────┼────────────────────┴─┘XXXXXXXXXXXXXXXXX  ┘ │
*   k+1 │                   │XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX    │
*   k+2 │                   │XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX    │
*     … │       i ± k       │XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX    │
*     … │                   │XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX    │ 
*   k+c │                   │XXXXXXXXXXXX                XXXXXXXXXXXX    │
*  ─────┼───────────────────┤XXXXXXXXXXXX    Run-time    XXXXXXXXXXXX    │
* k+c+1 │               ___/XXXXXXXXXXXXX  type checked  XXXXXXXXXXXX    │
*     … │           ___/XXXXXXXXXXXXXXXXX                XXXXXXXXXXXX    │
*     … │       ___/XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX    │
*     … │   ___/XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX    │
* k+c+k │__/XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX    │
*                                                                      
*       └─────────┬─────────┘                               Compile-time
*                 └─────────────────────────────────────    type checked 
*/

// Left padded with 0, B_0N indicates a binary string *0{B_0N}
// Enumerate (max(2ⁱ-k, 0), 2ⁱ+k) ∀0≤i≤⌊log₂(k+c+k)⌋
// i.e.: {0, 1, 2, *(4-k, 4+k), *(8-k, 8+k), *(16-k, 16+k),..., *(2^⌊log₂(k+c+k)⌋-k, 2^⌊log₂(k+c+k)⌋+k)}

${genBooleanTypeAliases()}

fun <K: B<*, *>> K.shl() = F
fun <K: B<*, *>> K.times2() = F
fun <K: B<*, *>> K.times4() = F.F
fun <K: B<*, *>> K.times8() = F.F.F
fun <K: B<*, *>> K.times16() = F.F.F.F

@JvmName("bnp1") fun Ø.plus1() = T(Ø)
${genBooleanPlusMinusOne(maxPow = 8)}

${genBooleanPlusMinus()}
"""

fun genBooleanTypeAliases(k: Int = 8): String =
  (0..8).asSequence().map { 2.0.pow(it).toInt() }
    .map { (it - k).coerceAtLeast(0) until (it + k) }
    .flatten().distinct().joinToString("\n") { "typealias B_$it<B> = ${it.toBigEndian("B")}" }

fun genBooleanPlusMinus(k: Int = 8): String =
  (2..k).joinToString("\n") { k ->
    val (p1, p2) = balancedPartition(k)

    val range = (0..8).asSequence().map { 2.0.pow(it).toInt() }
      .map { ((it - k).coerceAtLeast(0) until it).toList() }
      .flatten().distinct()
    range.joinToString("\n", "\n", "\n") {
      val result = it + k
      """@JvmName("b${it}p$k") fun B_${it}<Ø>.plus$k(): B_$result<Ø> = plus$p2().plus$p1()"""
    } + range.joinToString("\n", "\n", "\n") {
      val lpad = (it + k).toString(2).length - it.toString(2).length
      val fpad = "F".repeat(lpad).toBigEndian("K")
      """@JvmName("b?0${it}p$k") fun <K: B<*, *>> B_${it}<$fpad>.plus$k() = plus$p2().plus$p1()"""
    } + range.map { it + k }.joinToString("\n", "\n", "\n") {
      val result = it - k
      """@JvmName("b${it}m$k") fun B_${it}<Ø>.minus$k(): B_$result<Ø> = minus$p2().minus$p1()"""
    } + range.map { it + k }.joinToString("\n", "\n") {
      val result = it - k
      """@JvmName("b?${it}m$k") fun <K: B<*, *>> B_${it}<K>.minus$k() = minus$p2().minus$p1()"""
    }
  }

fun genBooleanPlusMinusOne(maxPow: Int, range: Sequence<Int> = (1..maxPow).asSequence().map { 2.0.pow(it).toInt() }) =
  """@JvmName("b0p1") fun B_0<Ø>.plus1() = T(Ø)""" +
    range.joinToString("\n", "\n") {
      val result = it
      """@JvmName("b${it - 1}p1") fun B_${it - 1}<Ø>.plus1(): B_$result<Ø> = F(x.plus1())"""
    } + "\n\n" + """@JvmName("b?0p1") fun <K: B<*, *>> B_0<K>.plus1() = T(x)""" +
    range.joinToString("\n", "\n", "\n\n") {
      """@JvmName("b?0${it - 1}p1") fun <K: B<*, *>> B_${it - 1}<F<K>>.plus1() = F(x.plus1())"""
    } + """
      @JvmName("b1m1") fun B_1<Ø>.minus1(): B_0<Ø> = F(Ø)
      @JvmName("b2m1") fun B_2<Ø>.minus1(): B_1<Ø> = T(Ø)
      """.trimIndent() +
    range.drop(1).joinToString("\n", "\n", "\n\n") {
      val result = it - 1
      """@JvmName("b${it}m1") fun B_${it}<Ø>.minus1(): B_$result<Ø> = T(x.minus1())"""
    } + """@JvmName("b?1p1") fun <K: B<*, *>> B_1<K>.minus1() = F(x)""" +
    range.joinToString("\n", "\n") {
      val result = it - 1
      """@JvmName("b?${it}m1") fun <K: B<*, *>> B_${it}<K>.minus1() = T(x.minus1())"""
    }

fun Int.toBigEndian(typeParam: String) =
  toString(2).fold(typeParam) { a, b -> if(b == '0') "F<$a>" else "T<$a>" }

fun String.toBigEndian(typeParam: String) = fold(typeParam) { a, b -> "$b<$a>" }